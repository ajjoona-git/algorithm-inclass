# 1861. 정사각형 방 | D4

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5LtJYKDzsDFAXc)


## 💡 접근 방식

### 1. 사용 알고리즘
* **구현 (Implementation)**
* **배열/리스트 처리 (Array/List Manipulation)**

### 2. 문제 풀이 과정
1.  **문제 재구성**: 이 문제는 N x N 격자에서 `k, k+1, k+2, ...` 와 같이 1씩 증가하며 인접해 있는 가장 긴 연속된 숫자열을 찾는 것입니다. 복잡한 그래프 탐색 대신, 먼저 모든 `k -> k+1` 연결 정보를 찾아낸 후, 가장 긴 연결 고리를 찾는 방식으로 접근할 수 있습니다.
2.  **1단계: 연결 정보 전처리**:
    * `N*N + 1` 크기의 1차원 리스트 `linked`를 생성합니다.
    * `linked[i]`는 `i`번 방과 `i+1`번 방이 서로 인접해 있는지 여부를 저장하는 역할을 합니다. (`1`이면 인접, `0`이면 비인접)
    * 2차원 `grid`를 모두 순회하면서, 각 방 `(r, c)`의 상하좌우를 확인합니다. 만약 인접한 방의 번호가 현재 방 번호보다 정확히 1 크다면, `linked[현재 방 번호]`에 `1`을 저장합니다.
3.  **2단계: 가장 긴 연속 구간 찾기**:
    * 전처리를 통해, 문제는 `linked` 리스트에서 **가장 긴 연속된 `1`의 구간**을 찾는 것으로 단순화됩니다.
    * `while` 반복문을 사용하여 `linked` 리스트를 1번 방부터 순회합니다.
    * 만약 `linked[num]`이 `1`이라면, 그 지점에서 연속된 경로가 시작됨을 의미합니다. 안쪽 `while`문을 통해 연속된 `1`이 몇 개나 이어지는지(`count`) 셉니다.
    * 계산된 `count`를 기존의 최대 길이(`max_count`)와 비교하여, 더 긴 경로가 발견되면 `max_count`와 시작 방 번호(`start`)를 갱신합니다.
4.  **효율적인 탐색**: 바깥쪽 `while`문의 인덱스 `num`은, 연속된 `1`의 구간을 찾은 후에 그 길이(`count`)만큼 건너뛰어 다음 탐색을 진행합니다. 이를 통해 이미 확인한 구간을 다시 검사하지 않아 효율적입니다.
5.  **결과 도출**: `max_count`는 가장 긴 경로의 간선(이동) 수를 의미하므로, 방의 총개수는 `max_count + 1`이 됩니다. 최종적으로 시작 방 번호 `start`와 방의 총개수를 출력합니다.



## 💻 코드
* [1861.py](1861.py)

---

## 💡 접근 방식 2: DFS + DP

### 1. 사용 알고리즘
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **메모이제이션 (Memoization) / 동적 계획법 (DP)**
* **재귀 (Recursion)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: N x N 격자에서, 현재 방보다 숫자가 정확히 1 큰 인접한 방으로만 이동하여 만들 수 있는 가장 긴 경로를 찾는 문제입니다. 모든 방이 시작점이 될 수 있으므로, 각 방에서 시작하는 경로의 길이를 모두 계산해야 합니다.
2.  **DFS + 메모이제이션**: 모든 방에서 DFS를 시작하면 동일한 경로를 반복적으로 계산하게 되어 비효율적입니다. 이를 해결하기 위해 **메모이제이션(Memoization)** 기법을 사용합니다.
    * `visited` 2차원 배열을 단순 방문 여부가 아닌, **해당 칸에서 시작했을 때 이동할 수 있는 최대 방의 개수**를 저장하는 DP 테이블로 활용합니다.
3.  **재귀 함수 `move(r, c)` 설계**:
    * **메모이제이션 확인**: 함수가 시작될 때, `visited[r][c]` 값이 0보다 크다면 이미 해당 칸에서 출발하는 경로의 길이가 계산된 것이므로, 재계산 없이 즉시 저장된 값을 반환합니다.
    * **탐색**: 현재 칸 `(r, c)`에서 상하좌우로 인접한 칸 `(nr, nc)`를 탐색하여, `grid[nr][nc] == grid[r][c] + 1` 조건을 만족하는 다음 방을 찾습니다.
    * **재귀 호출**: 다음 방을 찾았다면, `move(nr, nc)`를 재귀적으로 호출하여 다음 방에서부터 시작되는 경로의 길이를 가져옵니다. 현재 방의 경로 길이는 `1 + (다음 방에서 시작하는 경로의 길이)`가 됩니다.
    * **종료 조건 (Base Case)**: 만약 더 이상 이동할 수 있는 다음 방이 없다면, 현재 방에서 시작하는 경로는 길이 1이므로 `visited[r][c]`는 1이 되고, 이 값이 반환됩니다.
4.  **전체 탐색 및 결과 도출**:
    * `for` 루프를 통해 그리드의 모든 칸`(r, c)`을 순회하며 `move(r, c)`를 호출합니다. 메모이제이션 덕분에 각 칸에 대한 계산은 한 번만 수행됩니다.
    * `move` 함수가 반환하는 경로 길이(`count`)를 이전에 찾은 최대 길이(`max_count`)와 비교합니다.
    * 만약 `count`가 더 크면, `max_count`와 시작 방 번호 `start`를 갱신합니다.
    * `count`가 `max_count`와 같을 경우에는, 시작 방 번호가 더 작은 것으로 `start`를 갱신합니다.
    * 모든 칸에 대한 확인이 끝나면 최종 `start`와 `max_count`를 출력합니다.

## 💻 코드
* [1861_dfs.py](1861_dfs.py)
