# 4834. 숫자 카드

## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **구현(Implementation)**
* **딕셔너리(Dictionary)**를 활용한 빈도수 계산

### 2. 문제 풀이 과정
1.  먼저 카드 장수 `N`과 카드 숫자 문자열을 입력받습니다.
2.  카드 숫자와 그 개수를 저장할 빈 딕셔너리 `count_cards`를 생성합니다.
3.  입력받은 카드 문자열을 순회하면서 각 숫자를 키(key)로, 개수를 값(value)으로 딕셔너리에 저장합니다. 딕셔너리에 이미 존재하는 숫자라면 값에 1을 더하고, 처음 등장한 숫자라면 1로 초기화합니다.
4.  가장 많은 카드의 숫자와 장수를 찾기 위해 `max_count`와 `max_num` 변수를 초기화합니다.
5.  `count_cards` 딕셔너리를 순회하면서 현재 카드의 장수(`count`)가 `max_count`보다 크다면 `max_count`와 `max_num`을 갱신합니다.
6.  만약 현재 카드의 장수가 `max_count`와 같고, 카드 숫자(`num`)가 `max_num`보다 크다면 문제의 조건에 따라 `max_num`을 갱신합니다.
7.  모든 순회가 끝나면 `max_num`과 `max_count`를 출력합니다.

---

### 💻 코드
* [4834.py](4834.py)


## 💡 접근 방식 2

### 1. 사용 알고리즘
* **구현(Implementation)**
* **배열(Array)**을 활용한 빈도수 계산

### 2. 문제 풀이 과정
1.  먼저 카드 장수 `N`과 카드 숫자 문자열을 입력받습니다.
2.  0부터 9까지의 숫자가 몇 번 나왔는지 기록하기 위해 길이가 10인 리스트 `card_list`를 0으로 초기화하여 생성합니다. 이때 `card_list`의 인덱스는 카드 숫자를, 값은 해당 숫자의 빈도수를 의미합니다.
3.  입력받은 카드 문자열을 순회하며 각 문자를 정수로 변환한 뒤, 해당 숫자 인덱스에 해당하는 `card_list`의 값을 1씩 증가시켜 빈도수를 기록합니다.
4.  최빈수와 그 개수를 찾기 위해 `max_count`와 `max_count_number` 변수를 초기화합니다.
5.  `card_list`를 가장 큰 숫자(인덱스)부터 작은 숫자(인덱스) 순으로 순회합니다(9부터 0까지).
6.  만약 현재 숫자의 빈도수가 `max_count`보다 크다면, `max_count_number`를 현재 숫자로, `max_count`를 현재 빈도수로 갱신합니다.
7.  이 방식을 사용하면 빈도수가 같은 경우, 먼저 발견된 큰 숫자가 자동으로 선택되므로 문제의 조건(빈도수가 같을 때는 숫자가 큰 쪽을 출력)을 만족하게 됩니다.
8.  모든 순회가 끝나면 `max_count_number`와 `max_count`를 출력합니다.

---

### 💻 코드
* [4834v2.py](4834v2.py)