# 5102. 노드의 거리 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **그래프 (Graph)**
* **너비 우선 탐색 (BFS, Breadth-First Search)**
* **최단 경로 (Shortest Path)**
* **큐 (Queue)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 주어진 노드와 간선은 하나의 **무방향 그래프**를 형성합니다. 두 노드 사이의 '거리'는 이 그래프에서 두 노드를 잇는 **최단 경로의 간선 수**를 의미합니다.
2.  **알고리즘 선택**: 간선의 가중치가 없는 그래프에서 최단 경로를 찾는 문제에는 **너비 우선 탐색(BFS)**이 가장 적합합니다. BFS는 시작 노드로부터 거리가 가까운 순서대로 탐색을 진행하므로, 목표 노드에 처음 도달했을 때의 경로가 항상 최단 경로임을 보장합니다.
3.  **BFS를 이용한 최단 거리 계산**:
    * `bfs(s, g)` 함수는 시작 노드 `s`와 도착 노드 `g`를 인자로 받습니다.
    * `visited` 배열을 생성하여, **시작 노드 `s`로부터 각 노드까지의 경로에 포함된 노드의 개수**를 기록하는 용도로 사용합니다. (방문하지 않은 노드: `0`, 시작 노드: `1`)
    * 큐(Queue)를 생성하고 시작 노드 `s`를 추가하며 탐색을 시작합니다.
    * 큐에서 현재 노드(`current_node`)를 꺼내고, 그와 인접한 모든 노드(`next_node`)를 확인합니다.
    * 만약 `next_node`를 아직 방문하지 않았다면(`visited[next_node] == 0`), `visited[next_node]`에 `visited[current_node] + 1`을 저장하여 경로 길이를 갱신하고, 큐에 추가합니다.
4.  **목표 도달 및 종료**:
    * `next_node`가 우리가 찾던 도착 노드 `g`와 일치하는 순간, `visited[g]`에 저장된 값이 바로 `s`에서 `g`까지의 최단 경로에 포함된 **노드의 총개수**입니다.
    * 문제에서 요구하는 것은 간선의 수(이동 횟수)이므로, **(노드의 총개수 - 1)**을 계산한 값을 즉시 반환하고 탐색을 종료합니다.
    * 만약 큐가 모두 비워질 때까지 `g`에 도달하지 못했다면, 두 노드 사이에 경로가 존재하지 않는 것이므로 `0`을 반환합니다.

---

## 💻 코드
* [5102.py](5102.py)