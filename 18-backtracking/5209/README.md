# 5209. 최소 생산 비용 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **백트래킹 (Backtracking)**
* **깊이 우선 탐색 (DFS)**

### 2. 문제 풀이 과정
1.  이 문제는 `N`개의 제품을 `N`개의 공장에서 하나씩 생산하여 전체 생산 비용을 최소화하는 문제입니다. 각 공장은 한 종류의 제품만 생산할 수 있으므로, 이는 가능한 모든 **순열** 조합 중 최소 비용을 찾는 것과 같습니다.
2.  모든 조합을 효율적으로 탐색하기 위해 **백트래킹**을 사용합니다. `calculate_expense(product, expense)` 함수는 `product`번 제품을 생산할 공장을 결정하며, `expense`는 현재까지 누적된 비용입니다.
3.  어떤 공장이 특정 제품 생산에 이미 사용되었는지를 추적하기 위해 `visited` 배열을 사용합니다. `product`번 제품을 생산하기 위해 `0`번부터 `N-1`번까지의 모든 공장을 순회하며, 아직 방문하지 않은(`visited[factory] == False`) 공장을 선택합니다.
4.  공장을 선택하면 `visited[factory]`를 `True`로 설정하고, 다음 제품(`product + 1`)을 위해 누적 비용(`expense + arr[product][factory]`)과 함께 함수를 **재귀 호출**합니다.
5.  **백트래킹**: 재귀 호출이 끝나면 (즉, 해당 공장을 선택했을 때의 모든 하위 경로 탐색이 완료되면) `visited[factory]`를 다시 `False`로 되돌려 놓습니다. 이를 통해 다른 제품이 해당 공장을 선택하는 새로운 경로를 탐색할 수 있습니다.
6.  **가지치기**: 탐색 도중, 현재까지의 누적 비용(`expense`)이 이미 이전에 찾은 최소 비용(`min_expense`)보다 크거나 같아지면, 더 이상 탐색해도 최소 비용을 갱신할 가능성이 없으므로 해당 경로의 탐색을 즉시 중단합니다. 이는 불필요한 연산을 크게 줄여줍니다.
7.  **종료 조건**: 모든 제품(`product == N`)에 대한 공장 배치가 완료되면, 하나의 완전한 조합이 만들어진 것입니다. 이때의 총비용을 `min_expense`와 비교하여 더 작은 값으로 갱신합니다.
8.  초기값으로 `min_expense`를 충분히 큰 수로 설정하고 `calculate_expense(0, 0)`을 호출하여 탐색을 시작하면, 모든 탐색이 끝난 후 `min_expense`에 최종 결과가 저장됩니다.



---

## 💻 코드
* [5209.py](5209.py)