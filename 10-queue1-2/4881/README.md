# 4881. 배열 최소 합 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **순열 (Permutations)**
* **브루트포스 (Brute-force)**
* **백트래킹 (Backtracking) / 가지치기 (Pruning)**

### 2. 문제 풀이 과정
1.  N x N 배열에서 각 행마다 하나의 숫자를 선택하되, 선택된 숫자들의 열이 모두 달라야 하는 조건으로 최소 합을 구하는 문제입니다.
2.  이 조건은 N개의 열 인덱스(0부터 N-1)를 중복 없이 나열하는 모든 경우의 수를 탐색하는 것과 같습니다. 따라서 Python의 `itertools` 모듈에 있는 `permutations` 함수를 사용하여 모든 순열을 생성합니다.
3.  최소 합을 저장할 변수 `min_sum`을 아주 큰 수(무한대)로 초기화합니다.
4.  생성된 각 순열(`perm`)에 대해 합을 계산합니다. 순열의 `i`번째 값 `perm[i]`는 `i`번째 행에서 선택할 숫자의 열 인덱스를 의미합니다.
5.  하나의 순열에 대한 합(`current_sum`)을 계산하는 과정 중간에, `current_sum`이 이미 `min_sum`보다 커지는 경우가 발생할 수 있습니다.
6.  이 경우, 해당 순열은 더 이상 탐색해도 최소값을 갱신할 수 없으므로, 즉시 계산을 중단하고 다음 순열로 넘어갑니다. (가지치기)
7.  하나의 순열에 대한 합 계산이 끝까지 완료되면, 계산된 `current_sum`을 현재 `min_sum`과 비교하여 더 작은 값으로 `min_sum`을 갱신합니다.
8.  모든 순열에 대한 탐색이 끝나면 `min_sum`에 저장된 값이 최종적인 배열의 최소 합이 됩니다.

---

## 💻 코드
* [4881.py](4881.py)