# 1216. 회문2 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14Rq5aABUCFAYi)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **구현(Implementation)**
* **2차원 배열 순회** 및 **회문 검사**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스 번호와 100x100 크기의 글자판 `arr`를 입력받습니다.
2.  회문을 판별하는 함수 `is_palindrome`을 정의합니다. 이 함수는 문자열의 절반 길이만큼 순회하며 앞뒤 문자를 비교하여 회문 여부를 판별합니다.
3.  회문의 최대 길이를 저장할 `max_len` 변수를 `0`으로 초기화합니다.
4.  이중 반복문을 사용하여 글자판의 모든 위치(`i`, `j`)를 탐색합니다.
5.  최대 길이부터 현재까지 찾은 최대 길이까지 **길이(`k`)를 역순으로 순회**하는 반복문을 추가합니다. 이는 긴 길이의 회문을 먼저 찾으면 더 짧은 길이의 회문은 검사할 필요가 없어지는 **가지치기** 효과를 얻기 위함입니다.
6.  각 위치(`i`, `j`)와 길이(`k`)에 대해 **가로 방향** 문자열을 슬라이싱하여 회문인지 확인합니다.
7.  **세로 방향** 문자열은 `zip()` 함수를 사용하여 2차원 배열을 전치(transpose)한 후 슬라이싱하여 회문인지 확인합니다.
8.  만약 회문이 발견되면 `max_len`을 `k`로 갱신하고 다음 탐색으로 넘어갑니다.
9.  모든 탐색이 끝나면 `max_len`에 저장된 최종 회문의 길이를 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [1216.py](1216.py)



## 💡 접근 방식 2

### 1. 사용 알고리즘
* **구현(Implementation)**
* **2차원 배열 순회** 및 **회문 검사**
* **가지치기(Pruning)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스 번호와 100x100 크기의 글자판 `arr`를 입력받습니다.
2.  `zip(*arr)`를 활용하여 행과 열을 바꾼 **전치 행렬** `rotated_arr`를 생성합니다. 이를 통해 세로 방향의 회문을 가로 방향 탐색과 동일한 방식으로 검사할 수 있습니다.
3.  회문을 판별하는 함수 `is_palindrome`을 정의합니다.
4.  회문의 최대 길이를 저장할 `max_len` 변수를 `0`으로 초기화합니다.
5.  글자판의 모든 위치(`i`, `j`)를 순회하는 이중 반복문을 사용하고, 가장 긴 길이부터 `max_len`까지 **길이(`k`)를 역순으로** 탐색하는 반복문을 추가합니다. 이는 긴 길이의 회문을 먼저 찾으면 더 짧은 회문은 검사하지 않아도 되는 **가지치기** 효과를 얻기 위함입니다.
6.  각 위치(`i`, `j`)와 길이(`k`)에 대해 **가로 방향**(`arr[i]`)과 **세로 방향**(`rotated_arr[i]`)의 부분 문자열을 슬라이싱하여 회문인지 확인합니다.
7.  회문이 발견되면 `max_len`을 `k`로 갱신하고 다음 위치로 이동합니다.
8.  모든 탐색이 끝나면 `max_len`에 저장된 최종 회문의 길이를 출력 형식에 맞춰 출력합니다.

---

## 💻 코드
* [1216v2.py](1216v2.py)


---

## 두 코드 비교

1번 코드의 시간 복잡도: 약 $O(N^5)$
    
  1번 코드는 세로 회문을 찾을 때마다 `word = list(zip(*arr[j:j+k]))[i]`와 같이 zip 함수를 이용해 전치 행렬(transposed matrix)을 매번 새롭게 생성합니다.

2번 코드의 시간 복잡도: 약 $O(N^4)$

  2번 코드는 메인 로직을 시작하기 전에 `rotated_arr = list(zip(*arr))`를 사용하여 전체 전치 행렬을 단 한 번만 미리 계산합니다.