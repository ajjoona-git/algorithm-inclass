# 5204. 병합 정렬 | D3


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **병합 정렬 (Merge Sort)**
* **분할 정복 (Divide and Conquer)**
* **재귀 (Recursion)**

### 2. 문제 풀이 과정
1.  **문제 목표**: N개의 정수를 **병합 정렬**로 정렬하고, 그 과정에서 특정 조건을 만족하는 횟수를 세어 정렬 후 N/2번째 원소와 함께 출력하는 것입니다.
2.  **병합 정렬 구현 (분할 정복)**:
    * **분할(Divide)**: `merge_sort` 함수는 주어진 리스트(`arr`)의 길이가 1 이하가 될 때까지 재귀적으로 리스트를 절반으로 계속 나눕니다. 이는 재귀의 종료 조건이 됩니다.
    * **정복(Conquer) 및 병합(Merge)**: 더 이상 나눌 수 없는 리스트(길이가 1 이하)부터, 두 개의 정렬된 하위 리스트(`left`, `right`)를 하나의 정렬된 리스트(`merged_arr`)로 합칩니다. 이 과정은 두 리스트의 첫 원소부터 비교하며 더 작은 값을 새 리스트에 추가하는 방식으로 진행됩니다.
3.  **특수 조건 카운팅**:
    * 문제의 핵심 요구사항은 **왼쪽 부분 리스트의 마지막 원소가 오른쪽 부분 리스트의 마지막 원소보다 큰 경우**의 수를 세는 것입니다.
    * 이 조건은 두 하위 리스트(`left`, `right`)에 대한 `merge_sort` 재귀 호출이 끝나 각각 정렬된 상태로 반환된 직후, 그리고 두 리스트를 병합하기 직전에 검사합니다.
    * `left[-1] > right[-1]` 조건이 참일 때마다 전역 변수 `count`를 1 증가시킵니다.
4.  **최종 결과 도출**:
    * 최초의 `merge_sort(arr)` 호출이 완료되면, 리스트 전체가 정렬됩니다.
    * 정렬된 리스트(`sorted_arr`)의 N/2번째 원소와, 정렬 과정 동안 누적된 `count` 값을 함께 출력합니다.

---

## 💻 코드
* [5204.py](5204.py)