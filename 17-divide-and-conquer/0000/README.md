# 연습 문제. 퀵 정렬

## 문제 출처
![문제](../../images/17-quick.png)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **퀵 정렬 (Quick Sort)**
* **분할 정복 (Divide and Conquer)**
* **재귀 (Recursion)**

### 2. 문제 풀이 과정
1.  **핵심 아이디어 (분할 정복)**: 퀵 정렬은 대표적인 **분할 정복(Divide and Conquer)** 알고리즘입니다. 리스트 내에서 하나의 기준점(**피벗, pivot**)을 정하고, 피벗보다 작은 값들의 리스트와 큰 값들의 리스트로 분할한 뒤, 각 리스트에 대해 이 과정을 재귀적으로 반복하여 정렬을 수행합니다.
2.  **피벗 선택**: 이 코드에서는 리스트의 **중앙에 위치한 값**을 피벗으로 선택합니다.
3.  **분할 (Partition)**:
    * 리스트 내포(List Comprehension)를 사용하여 원본 리스트를 세 부분으로 효율적으로 분할합니다.
        * **`left`**: 피벗보다 작은 값들을 모은 리스트
        * **`middle`**: 피벗과 동일한 값들을 모은 리스트 (중복 값 처리)
        * **`right`**: 피벗보다 큰 값들을 모은 리스트
4.  **정복 및 조합 (Conquer and Combine)**:
    * 분할된 `left` 리스트와 `right` 리스트에 대해 `quick_sort` 함수를 **재귀적으로 호출**하여 각각 정렬을 수행합니다.
    * 정렬된 `left` 리스트, `middle` 리스트, 정렬된 `right` 리스트를 순서대로 이어 붙여(`+`) 전체 리스트의 정렬을 완성합니다.
5.  **종료 조건**: 재귀 호출은 분할된 리스트의 길이가 1 이하가 될 때까지 계속됩니다. 길이가 1 이하인 리스트는 이미 정렬된 상태이므로, 더 이상 분할하지 않고 그대로 반환하면서 재귀가 종료됩니다.


### 💻 코드
* [0000.py](0000.py)

---

## 💡 접근 방식 2

### 1. 사용 알고리즘
* **퀵 정렬 (Quick Sort)**
* **분할 정복 (Divide and Conquer)**
* **재귀 (Recursion)**
* **Lomuto 분할 방식 (Lomuto Partition Scheme)**

### 2. 문제 풀이 과정
1.  **핵심 아이디어 (분할 정복)**: 퀵 정렬은 **분할 정복** 패러다임을 따르는 대표적인 정렬 알고리즘입니다. 이 풀이에서는 새로운 리스트를 생성하지 않고 주어진 리스트 내에서 직접 원소의 위치를 바꾸는 **제자리(in-place)** 정렬 방식으로 구현합니다.
2.  **분할 과정 (`partition` 함수)**:
    * **Lomuto 분할 방식**을 사용하여 배열을 피벗(pivot) 기준으로 분할합니다.
    * 주어진 배열 구간의 **마지막 원소를 피벗으로** 선택합니다.
    * 배열을 순회하며 피벗보다 작은 원소들은 왼쪽으로, 크거나 같은 원소들은 오른쪽으로 재배치합니다.
    * 모든 원소 확인이 끝나면, 피벗을 경계 지점에 위치시켜 피벗의 최종 위치를 확정하고 해당 인덱스를 반환합니다.
3.  **재귀적 정복 (`quick_sort` 함수)**:
    * `partition` 함수를 호출하여 피벗의 위치를 얻습니다.
    * 피벗을 기준으로 나뉜 왼쪽 하위 배열(`start` ~ `pivot_idx - 1`)과 오른쪽 하위 배열(`pivot_idx + 1` ~ `end`)에 대해 `quick_sort` 함수를 **재귀적으로 호출**합니다.
    * 이 재귀는 분할된 배열의 크기가 1 이하가 될 때(`start >= end`)까지 계속됩니다.
4.  **실행 및 결과 출력**:
    * `quick_sort(arr, 0, len(arr)-1)`를 호출하여 전체 배열에 대한 정렬을 시작합니다.
    * 모든 재귀 호출이 완료되면 원본 배열 `arr` 자체가 정렬된 상태가 되며, 이를 형식에 맞게 출력합니다.

### 💻 코드
* [0000v2.py](0000v2.py)