# 연습 문제. 퀵 정렬

## 문제 출처
![문제](../../images/17-quick.png)

## 💡 접근 방식

### 1. 사용 알고리즘
* **퀵 정렬 (Quick Sort)**
* **분할 정복 (Divide and Conquer)**
* **재귀 (Recursion)**

### 2. 문제 풀이 과정
1.  **핵심 아이디어 (분할 정복)**: 퀵 정렬은 대표적인 **분할 정복(Divide and Conquer)** 알고리즘입니다. 리스트 내에서 하나의 기준점(**피벗, pivot**)을 정하고, 피벗보다 작은 값들의 리스트와 큰 값들의 리스트로 분할한 뒤, 각 리스트에 대해 이 과정을 재귀적으로 반복하여 정렬을 수행합니다.
2.  **피벗 선택**: 이 코드에서는 리스트의 **중앙에 위치한 값**을 피벗으로 선택합니다.
3.  **분할 (Partition)**:
    * 리스트 내포(List Comprehension)를 사용하여 원본 리스트를 세 부분으로 효율적으로 분할합니다.
        * **`left`**: 피벗보다 작은 값들을 모은 리스트
        * **`middle`**: 피벗과 동일한 값들을 모은 리스트 (중복 값 처리)
        * **`right`**: 피벗보다 큰 값들을 모은 리스트
4.  **정복 및 조합 (Conquer and Combine)**:
    * 분할된 `left` 리스트와 `right` 리스트에 대해 `quick_sort` 함수를 **재귀적으로 호출**하여 각각 정렬을 수행합니다.
    * 정렬된 `left` 리스트, `middle` 리스트, 정렬된 `right` 리스트를 순서대로 이어 붙여(`+`) 전체 리스트의 정렬을 완성합니다.
5.  **종료 조건**: 재귀 호출은 분할된 리스트의 길이가 1 이하가 될 때까지 계속됩니다. 길이가 1 이하인 리스트는 이미 정렬된 상태이므로, 더 이상 분할하지 않고 그대로 반환하면서 재귀가 종료됩니다.


---

## 💻 코드
* [0000.py](0000.py)