# 5189. 전자카트 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / 순열 (Permutations)**
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **백트래킹 (Backtracking)**
* **가지치기 (Pruning)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 사무실에서 출발하여 모든 관리구역을 한 번씩만 방문하고 다시 사무실로 돌아오는 최소 비용 경로를 찾는 문제입니다. 이는 모든 방문 순서(순열)를 고려해야 하는 **외판원 순회 문제(TSP, Traveling Salesperson Problem)**와 같습니다. N의 크기가 작으므로, 모든 경로를 탐색하는 **완전 탐색**으로 해결할 수 있습니다.
2.  **DFS와 백트래킹을 이용한 순열 생성**:
    * 재귀 함수 `minimum_path(start, cnt, total)`를 사용하여 깊이 우선 탐색(DFS) 방식으로 모든 방문 경로(순열)를 생성합니다.
    * `start`는 현재 위치, `cnt`는 방문한 관리구역의 수, `total`은 현재까지의 배터리 사용량입니다.
    * `visited` 배열을 사용하여 각 관리구역의 방문 여부를 추적합니다.
    * `for` 루프를 통해 아직 방문하지 않은(`not visited`) 다음 관리구역(`next_node`)으로 이동하는 모든 경우를 탐색합니다.
    * **백트래킹**: 특정 `next_node`에 대한 재귀 호출이 끝난 후, `visited[next_node]`를 다시 `False`로 되돌립니다. 이 과정을 통해 다른 경로(순열)를 탐색할 때 해당 노드를 다시 방문할 수 있도록 길을 열어줍니다.
3.  **종료 조건**:
    * `cnt`가 `N-1`이 되면 모든 관리구역을 방문한 것이므로, 현재 위치에서 사무실(1번)로 복귀하는 비용을 `total`에 더해줍니다.
    * 계산된 최종 비용을 전역 변수 `result`(최소 비용)와 비교하여 더 작은 값으로 갱신합니다.
4.  **가지치기(Pruning)를 통한 최적화**:
    * 탐색 도중, 현재까지의 비용 `total`이 이미 이전에 찾은 최소 비용 `result`보다 크거나 같아진다면, 해당 경로는 더 이상 탐색해도 최소값을 갱신할 수 없습니다.
    * 이 경우, 즉시 `return`하여 불필요한 탐색을 중단하고 효율성을 높입니다.
5.  **실행**: 사무실(1번)에서 `minimum_path(1, 0, 0)`을 호출하여 탐색을 시작하고, 모든 탐색이 끝난 뒤 `result`에 저장된 최종 최소값을 출력합니다.

---

## 💻 코드
* [5189.py](5189.py)