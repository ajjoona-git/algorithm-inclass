# 1244. 최대 상금 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15Khn6AN0CFAYD&categoryId=AV15Khn6AN0CFAYD&categoryType=CODE&problemTitle=1244&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / DFS**
* **백트래킹 (Backtracking)**
* **메모이제이션 (Memoization) / 가지치기 (Pruning)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 주어진 횟수(`N`)만큼 숫자의 위치를 교환하여 만들 수 있는 가장 큰 수를 찾는 문제입니다. 이는 가능한 모든 교환 경우의 수를 탐색해야 하는 **완전 탐색** 문제로 볼 수 있습니다. 탐색은 **깊이 우선 탐색(DFS)** 방식의 재귀로 구현합니다.
2.  **재귀를 이용한 DFS와 백트래킹**:
    * `swap_digit(cnt)` 함수는 `cnt`번 교환이 이루어진 상태에서 다음 교환을 진행하는 재귀 함수입니다.
    * **탐색**: 이중 `for`문을 사용하여 교환할 두 자리(`idx_1`, `idx_2`)를 선택하는 모든 조합을 만듭니다.
    * **재귀 호출**: 두 자리의 숫자를 교환한 후, 교환 횟수를 1 증가시켜 `swap_digit(cnt + 1)`을 재귀적으로 호출합니다.
    * **백트래킹**: 재귀 호출이 끝난 후에는, **교환했던 두 숫자를 다시 원래대로 되돌려 놓습니다.** 이 과정을 통해 다른 교환 조합을 탐색할 때 영향을 주지 않도록 상태를 원상 복구합니다.
    * **종료 조건**: 교환 횟수 `cnt`가 `N`과 같아지면, 정해진 횟수만큼의 교환이 완료된 것이므로 현재 만들어진 숫자를 `result`(최대값)와 비교하여 갱신합니다.
3.  **메모이제이션을 통한 최적화 (가지치기)**:
    * 단순 완전 탐색은 `(교환 횟수, 현재 숫자)`가 동일한 상태를 중복으로 탐색하여 시간 초과를 유발할 수 있습니다. (예: `123` -> `213` (1회) -> `123` (2회))
    * 이를 방지하기 위해 `swap_cases`라는 `set`을 사용하여 **메모이제이션**을 적용합니다.
    * `(현재 교환 횟수, 현재 숫자)` 쌍을 `swap_cases`에 기록하고, 재귀 함수가 호출될 때마다 이미 `swap_cases`에 현재 상태가 기록되어 있는지 확인합니다.
    * 만약 이미 탐색했던 상태라면, 더 이상 탐색하지 않고 즉시 `return`하여 불필요한 계산을 줄입니다(가지치기).
4.  **실행**: `swap_digit(0)`을 호출하여 0회 교환 상태부터 탐색을 시작하고, 모든 탐색이 끝난 뒤 `result`에 저장된 최종 최대값을 출력합니다.

---

## 💻 코드
* [1244.py](1244.py)