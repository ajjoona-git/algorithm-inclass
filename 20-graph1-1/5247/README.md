# 5247. 연산 | D4


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **너비 우선 탐색 (BFS, Breadth-First Search)**
* **최단 경로 (Shortest Path)**
* **그래프 (Graph)**
* **큐 (Queue)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 이 문제는 시작 숫자 N에서 4가지 연산(간선)을 통해 목표 숫자 M에 도달하는 **최소 연산 횟수(최단 경로)**를 찾는 것과 같습니다. 이는 각 숫자를 정점(Vertex)으로, 4가지 연산을 간선(Edge)으로 하는 **가중치가 없는 그래프**에서 최단 경로를 찾는 문제로 모델링할 수 있습니다.
2.  **알고리즘 선택**: 가중치가 없는 그래프에서 최단 경로를 찾는 데에는 **너비 우선 탐색(BFS)**이 가장 적합합니다. BFS는 시작점으로부터 거리가 1인 정점, 2인 정점, ... 순서로 탐색을 확장해 나가므로, 목표 지점에 처음 도달했을 때의 경로가 항상 최단 경로임을 보장합니다.
3.  **BFS 구현**:
    * **큐(Queue)**: 탐색할 상태 `(현재 숫자, 현재까지의 연산 횟수)`를 저장하는 큐를 사용합니다.
    * **`visited` 집합(Set)**: 한 번이라도 큐에 추가되었던 숫자를 기록하여 중복 탐색을 방지합니다. `set`을 사용하면 특정 숫자의 방문 여부를 O(1)의 시간 복잡도로 빠르게 확인할 수 있습니다.
4.  **탐색 과정**:
    1.  큐에 시작 상태 `(N, 0)`을 추가하고, `visited` set에 `N`을 추가합니다.
    2.  큐가 빌 때까지 다음을 반복합니다.
    3.  큐에서 `(num, count)`를 꺼냅니다.
    4.  만약 `num`이 목표 숫자 `M`과 같다면, 탐색을 종료하고 `count`를 결과로 반환합니다.
    5.  그렇지 않다면, `num`에 4가지 연산(`+1`, `-1`, `*2`, `-10`)을 각각 적용하여 `next_num`을 생성합니다.
    6.  각 `next_num`에 대해 **유효한 숫자 범위(1~1,000,000)에 있고 아직 `visited` set에 없는 경우**에만, `visited`에 추가하고 `(next_num, count + 1)`을 큐에 추가합니다.
5.  **결과 도출**: BFS 탐색 중 목표 숫자 `M`에 도달했을 때의 `count`가 최소 연산 횟수가 됩니다.

---

## 💻 코드
* [5247.py](5247.py)