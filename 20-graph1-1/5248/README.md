# 5248. 그룹 나누기 | D3


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **서로소 집합 (Disjoint Set Union, DSU)**
* **Union-Find**
* **경로 압축 (Path Compression)**
* **랭크 기반 통합 (Union by Rank)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 여러 개의 개별 원소(학생)들을 주어진 관계(같은 조)에 따라 그룹으로 묶고, 최종적으로 몇 개의 그룹이 형성되는지 세는 문제입니다. 이는 **서로소 집합(Disjoint Set Union)** 자료구조를 사용하기에 가장 적합한 전형적인 문제입니다.
2.  **서로소 집합 초기화**:
    * `parent` 배열을 생성하고, 처음에는 각 학생이 자기 자신을 대표로 하는 개별 집합을 형성하도록 초기화합니다 (`parent[i] = i`).
    * `rank` 배열을 0으로 초기화하여, `union` 연산 시 트리의 높이를 관리하는 데 사용합니다.
3.  **Union-Find 연산 구현**:
    * **`find_set(x)`**: `x`가 속한 집합의 대표 원소(루트)를 찾는 함수입니다. 재귀 호출을 통해 부모를 거슬러 올라가며, 찾은 루트를 자신의 부모로 직접 연결하도록 `parent` 값을 갱신합니다. 이 **경로 압축(Path Compression)** 최적화를 통해 후속 `find` 연산의 속도를 크게 향상시킵니다.
    * **`union(x, y)`**: `x`와 `y`가 속한 두 집합을 하나로 합치는 함수입니다. **랭크 기반 통합(Union by Rank)** 최적화를 사용하여, 항상 `rank`(트리의 높이)가 낮은 트리를 높은 트리 밑에 붙입니다. 이를 통해 트리가 한쪽으로 길어지는 것을 방지하고 균형을 유지하여 `find` 연산의 효율을 보장합니다.
4.  **그룹 형성**:
    * 입력으로 주어진 M개의 관계 쌍 `(v1, v2)`을 순회하면서, 각 쌍에 대해 `union(v1, v2)` 연산을 수행하여 같은 조인 학생들을 하나의 집합으로 합칩니다.
5.  **최종 그룹 수 계산**:
    * 모든 `union` 연산이 끝난 후, 1번부터 N번까지의 모든 학생에 대해 `find_set(i)`를 호출하여 각 학생이 속한 집합의 최종 대표 원소를 찾습니다.
    * 찾아낸 대표 원소들을 `set` 자료구조에 추가하여 중복을 제거합니다.
    * 최종적으로 `set`의 크기(`len`)가 바로 서로 다른 그룹의 총개수가 됩니다.

---

## 💻 코드
* [5248.py](5248.py)