# 5251. 최소 이동 거리 | D4


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **그래프 (Graph)**
* **최단 경로 (Shortest Path)**
* **다익스트라 알고리즘 (Dijkstra's Algorithm)**
* **우선순위 큐 (Priority Queue) / 힙 (Heap)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 각 지점을 정점(Vertex)으로, 도로를 간선(Edge)으로 하는 **가중치 유향 그래프(Weighted Directed Graph)**로 문제를 모델링합니다. 목표는 0번 지점에서 N번 지점까지의 **최단 경로** 비용을 찾는 것입니다.
2.  **알고리즘 선택**: 간선의 가중치(이동 거리)가 모두 0 이상이므로, 시작점에서부터 다른 모든 정점까지의 최단 경로를 찾는 데 가장 효율적인 알고리즘인 **다익스트라 알고리즘**을 사용합니다.
3.  **다익스트라 알고리즘 구현**:
    * **`distances` 배열**: 0번 지점으로부터 각 지점(`node`)까지의 최소 이동 거리를 저장하는 1차원 배열입니다. 모든 값을 무한대(INF)로 초기화하고, 시작점 `distances[0]`은 `0`으로 설정합니다.
    * **우선순위 큐 (Priority Queue)**: 다음으로 탐색할 정점을 선택할 때, 현재까지 계산된 거리가 가장 짧은 정점을 항상 먼저 선택해야 합니다. 이를 효율적으로 구현하기 위해 **최소 힙(min-heap)**을 우선순위 큐로 사용하며, 큐에는 `(거리, 노드 번호)` 튜플을 저장합니다.
4.  **탐색 과정**:
    1.  시작점 `(거리:0, 노드:0)`을 우선순위 큐에 추가합니다.
    2.  큐가 빌 때까지 다음을 반복합니다.
    3.  큐에서 현재까지의 거리가 가장 짧은 노드(`cost`, `node`)를 꺼냅니다.
    4.  만약 `cost`가 `distances[node]`에 기록된 거리보다 크다면, 이미 더 빠른 경로가 발견된 것이므로 무시하고 넘어갑니다.
    5.  현재 노드(`node`)와 연결된 모든 인접 노드(`next_node`)를 탐색하며, 기존에 알려진 거리보다 현재 노드를 거쳐 가는 거리가 더 짧다면(`cost + next_cost < distances[next_node]`), `distances` 배열을 갱신하고 해당 노드의 정보 `(갱신된 거리, next_node)`를 우선순위 큐에 추가합니다. (Relaxation 과정)
5.  **결과 도출**: `dijkstra` 함수가 종료되면 `distances[N]`에 0번 지점에서 N번 지점까지의 최소 이동 거리가 저장되어 있으며, 이 값을 출력합니다.
---

## 💻 코드
* [5251.py](5251.py)