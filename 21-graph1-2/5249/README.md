# 5249. 최소 신장 트리 | D4


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식 1: 프림(Prim)

### 1. 사용 알고리즘
* **최소 신장 트리 (Minimum Spanning Tree, MST)**
* **프림 알고리즘 (Prim's Algorithm)**
* **그리디 알고리즘 (Greedy Algorithm)**
* **우선순위 큐 (Priority Queue) / 힙 (Heap)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 주어진 모든 정점(V)들을 최소한의 비용(가중치 합)으로 연결하는 경로를 찾는 문제입니다. 이는 그래프의 모든 정점을 포함하면서 사이클이 없고, 간선들의 가중치 합이 최소가 되는 **최소 신장 트리(MST)**를 구성하는 것과 같습니다.
2.  **알고리즘 선택**: MST를 찾는 대표적인 알고리즘 중 하나인 **프림(Prim) 알고리즘**을 사용합니다. 프림 알고리즘은 임의의 한 정점에서 시작하여, 현재까지 만들어진 트리에 인접한 간선 중 가장 가중치가 낮은 간선을 선택하여 트리를 확장해 나가는 **그리디(Greedy)** 방식입니다.
3.  **우선순위 큐를 이용한 구현**:
    * **`visited` 배열**: 각 정점이 MST에 포함되었는지 여부를 확인합니다.
    * **우선순위 큐 (최소 힙)**: 현재 MST에 포함된 정점들과 인접한 간선들을 저장하는 역할을 합니다. 큐에는 `(가중치, 연결된 정점)` 튜플을 저장하여, 항상 가중치가 가장 낮은 간선을 O(log N) 시간 복잡도로 효율적으로 꺼낼 수 있도록 합니다.
4.  **프림 알고리즘 탐색 과정**:
    1.  임의의 시작 정점(예: 0번)을 우선순위 큐에 `(비용:0, 정점:0)` 형태로 넣고 탐색을 시작합니다.
    2.  큐가 빌 때까지 다음을 반복합니다.
    3.  큐에서 현재 가장 가중치가 낮은 간선 정보 `(cost, curr_node)`를 꺼냅니다.
    4.  만약 `curr_node`가 이미 방문한 정점이라면, 사이클이 형성될 수 있으므로 무시하고 다음으로 넘어갑니다.
    5.  `curr_node`가 아직 방문하지 않은 정점이라면, MST에 포함시킵니다. `visited`를 `True`로 변경하고, 총비용 `min_cost`에 `cost`를 더합니다.
    6.  새롭게 MST에 포함된 `curr_node`와 연결된 모든 간선을 확인하며, 아직 방문하지 않은 인접 정점(`next_node`)들을 우선순위 큐에 추가합니다.
5.  **결과 도출**: 모든 정점이 MST에 포함되면 탐색이 종료되고, `min_cost`에 저장된 값이 MST의 최종 가중치 합이 됩니다.

### 💻 코드
* [5249_prim.py](5249_prim.py)
---


## 💡 접근 방식 2: 크루스칼(Kruskal)

### 1. 사용 알고리즘
* **최소 신장 트리 (Minimum Spanning Tree, MST)**
* **크루스칼 알고리즘 (Kruskal's Algorithm)**
* **그리디 알고리즘 (Greedy Algorithm)**
* **서로소 집합 (Disjoint Set Union, DSU)**
* **정렬 (Sorting)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 주어진 모든 정점(V)들을 최소한의 비용(가중치 합)으로 연결하는 경로를 찾는 문제입니다. 이는 그래프의 모든 정점을 포함하면서 사이클이 없고, 간선들의 가중치 합이 최소가 되는 **최소 신장 트리(MST)**를 구성하는 것과 같습니다.
2.  **알고리즘 선택**: MST를 찾는 대표적인 알고리즘 중 하나인 **크루스칼(Kruskal) 알고리즘**을 사용합니다. 크루스칼 알고리즘은 가중치가 가장 작은 간선부터 차례대로 확인하며, 사이클을 만들지 않는 간선만 선택해 나가는 **그리디(Greedy)** 방식입니다.
3.  **크루스칼 알고리즘 탐색 과정**:
    * **1단계 (간선 정렬)**: 모든 간선(`edges`)을 가중치(`w`)를 기준으로 **오름차순 정렬**합니다.
    * **2단계 (사이클 확인 및 간선 선택)**: 가중치가 낮은 간선부터 순서대로 다음을 확인합니다.
        * 현재 간선이 연결하는 두 정점(`n1`, `n2`)이 **이미 같은 집합에 속해 있는지** 검사합니다.
        * 이 검사는 **서로소 집합(Union-Find)** 자료구조를 통해 효율적으로 수행됩니다. `find_set(n1) == find_set(n2)`가 참이면, 두 정점은 이미 연결되어 있으므로 이 간선을 추가하면 사이클이 형성됩니다. 따라서 해당 간선은 무시합니다.
        * 만약 두 정점이 서로 다른 집합에 속해 있다면, 사이클을 형성하지 않으므로 이 간선을 MST에 포함시킵니다.
    * **3단계 (가중치 합산 및 집합 통합)**: 간선을 MST에 포함시키기로 결정하면, 해당 간선의 가중치를 `min_cost`에 더하고, `union(parents, n1, n2)` 연산을 통해 두 정점이 속한 집합을 하나로 합쳐줍니다.
4.  **결과 도출**: 위 과정을 `V-1`개의 간선이 선택될 때까지 반복합니다. `V-1`개의 간선이 모이면 MST가 완성되며, 이때의 `min_cost`가 최소 신장 트리의 총가중치가 됩니다.

### 💻 코드
* [5249_kruskal.py](5249_kruskal.py)
