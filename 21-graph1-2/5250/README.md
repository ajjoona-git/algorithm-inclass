# 5250. 최소 비용 | D3


## 문제 출처
[SWEA](https://swexpertacademy.com/main/learn/course/lectureProblemViewer.do)

## 💡 접근 방식

### 1. 사용 알고리즘
* **그래프 (Graph)**
* **최단 경로 (Shortest Path)**
* **다익스트라 알고리즘 (Dijkstra's Algorithm)**
* **우선순위 큐 (Priority Queue) / 힙 (Heap)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 지도를 하나의 **가중치 그래프(Weighted Graph)**로 간주합니다. 각 칸`(r, c)`은 정점(Vertex)이 되며, 인접한 칸으로 이동하는 것을 간선(Edge)으로 볼 수 있습니다. 간선의 가중치(비용)는 이동 규칙에 따라 동적으로 계산됩니다. 문제는 (0, 0)에서 (N-1, N-1)까지 도달하는 **최소 비용(최단 경로)**을 찾는 것입니다.
2.  **알고리즘 선택**: 간선의 가중치(소비 연료량)가 항상 0 이상이므로, 시작점에서부터 다른 모든 정점까지의 최단 경로를 찾는 데 가장 효율적인 **다익스트라 알고리즘**을 사용합니다.
3.  **다익스트라 알고리즘 구현**:
    * **`cost_matrix` 배열**: 시작점 `(0, 0)`으로부터 각 칸 `(r, c)`까지의 최소 연료 소비량을 저장하는 2차원 배열입니다. 모든 값을 무한대(INF)로 초기화하고, 시작점 `cost_matrix[0][0]`은 `0`으로 설정합니다.
    * **우선순위 큐 (Priority Queue)**: 다음으로 탐색할 정점을 선택할 때, 현재까지 계산된 비용이 가장 적은 정점을 항상 먼저 선택해야 합니다. 이를 위해 **최소 힙(min-heap)**을 우선순위 큐로 사용하며, 큐에는 `(비용, 행, 열)` 튜플을 저장합니다.
4.  **비용 계산 로직 (가중치)**:
    * 현재 칸 `(r, c)`에서 인접한 칸 `(nr, nc)`으로 이동할 때의 비용은 다음과 같이 계산됩니다.
        * **기본 비용**: 1
        * **추가 비용**: 만약 `grid[nr][nc] > grid[r][c]` (더 높은 곳으로 이동)이라면, 높이 차이 `(grid[nr][nc] - grid[r][c])`만큼 비용이 추가됩니다.
5.  **탐색 과정**:
    1.  시작점 `(0, 0, 0)`을 우선순위 큐에 추가합니다.
    2.  큐가 빌 때까지 다음을 반복합니다.
    3.  큐에서 현재까지의 비용이 가장 작은 정점(`cost`, `r`, `c`)을 꺼냅니다.
    4.  만약 `cost`가 `cost_matrix[r][c]`에 기록된 비용보다 크다면, 이미 더 빠른 경로가 발견된 것이므로 무시하고 넘어갑니다.
    5.  현재 정점과 인접한 상하좌우 칸들을 탐색하며, 위 비용 계산 로직에 따라 인접 칸까지의 새로운 비용(`next_cost`)을 계산합니다.
    6.  만약 `next_cost`가 기존에 알려진 비용(`cost_matrix[nr][nc]`)보다 작다면, `cost_matrix`를 갱신하고 `(next_cost, nr, nc)`를 우선순위 큐에 추가합니다. (Relaxation 과정)
6.  **결과 도출**: `dijkstra` 함수가 종료되면 `cost_matrix[N-1][N-1]`에 도착지까지의 최소 비용이 저장되어 있으며, 이 값을 출력합니다.

---

## 💻 코드
* [5250.py](5250.py)