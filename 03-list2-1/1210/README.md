# 1210. Ladder1 | D4

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14ABYKADACFAYh&categoryId=AV14ABYKADACFAYh&categoryType=CODE&problemTitle=1210&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현(Implementation)**
* **2차원 배열 역순회** 및 **방향 벡터(Delta Array)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 번호와 100x100 크기의 2차원 배열 `arr`를 입력받습니다.
2.  이 문제는 도착점(`'2'`)에서 출발점(`'1'`이 있는 행)까지 거꾸로 올라가는 방식으로 탐색하는 것이 효율적입니다.
3.  도착점의 좌표를 찾기 위해 배열의 마지막 행(`r = 99`)에서 `'2'`의 인덱스를 찾아 `(r, c)`를 초기화합니다.
4.  경로를 거슬러 올라가는 탐색을 위해 델타 배열을 **좌-우-상** 순서로 정의합니다. 이 순서는 갈림길에서 옆으로 먼저 이동하여 최단 경로를 찾는 데 도움이 됩니다.
5.  `while` 반복문을 사용하여 현재 행 `r`이 `0`보다 큰 동안 탐색을 계속합니다.
6.  `for` 반복문을 사용하여 현재 위치 `(r, c)`에서 좌, 우, 위 방향을 순서대로 확인합니다.
7.  다음 이동할 위치가 배열의 경계를 벗어나지 않고, 그 값이 `'1'`일 경우에만 이동합니다.
8.  이동한 위치 `(nr, nc)`를 새로운 `(r, c)`로 갱신하고, 이미 지나온 길은 다시 탐색하지 않도록 `arr[nr][nc]`의 값을 `'0'`으로 변경합니다.
9.  좌우로 갈 수 있는 길이 있다면 상 방향으로 이동하기 전에 `break`를 통해 좌우 탐색을 우선시합니다.
10. `while` 반복문이 종료되면, `r`이 `0`인 첫 번째 행에 도달한 것이며, 그 때의 열 위치 `c`가 최종 출발점이 됩니다.
11. 최종 결과를 테스트 케이스 번호와 함께 출력 형식에 맞춰 출력합니다.


---

## 💻 코드
* [1210.py](1210.py)