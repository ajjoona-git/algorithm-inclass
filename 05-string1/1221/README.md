# 1221. GNS | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZh9Pr4Kw1nHBINp&contestProbId=AV14jJh6ACYCFAYD&probBoxId=AZh-M3iq4UjHBINp&type=PROBLEM&problemBoxTitle=String&problemBoxCnt=5)


### 💡 접근 방식 1: 카운팅 정렬

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 카운팅 정렬(Counting Sort)

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 테스트 케이스 번호와 외계 행성 숫자의 개수 `len_s`를 입력받습니다.
2.  외계 행성의 숫자들을 문자열 형태로 `s` 리스트에 입력받습니다.
3.  문제의 요구사항은 문자열로 주어진 숫자들을 정해진 순서(`"ZRO", "ONE", ...`)대로 정렬하는 것이므로, **카운팅 정렬**이 효율적입니다.
4.  카운팅 정렬을 구현하는 함수 `counting_sort(arr, K)`를 정의합니다. 여기서 `K`는 숫자의 종류(0~9)를 의미합니다.
5.  **카운트 배열**(`count`)을 생성하여 각 숫자의 출현 횟수를 기록합니다. `numbers.index(num)`를 사용하여 각 문자열 숫자를 해당 인덱스(0~9)로 변환합니다.
6.  **카운트 배열의 누적합**을 계산하여, 각 숫자가 정렬된 배열에서 들어갈 최종 위치를 결정합니다.
7.  **결과 배열**(`sorted_arr`)을 생성하고, 입력받은 `arr`를 역순으로 순회하며 `count` 배열의 값을 이용하여 `sorted_arr`에 올바른 위치에 저장합니다.
8.  `counting_sort` 함수는 정렬된 배열을 반환합니다.
9.  각 테스트 케이스마다 `counting_sort` 함수를 호출하여 정렬된 `sorted_s`를 얻고, 테스트 케이스 번호와 정렬된 단어들을 출력 형식에 맞춰 출력합니다.

## 💻 코드
* [1221.py](1221.py)

---

### 💡 접근 방식 2: 버블 정렬

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 버블 정렬(Bubble Sort)

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 테스트 케이스 번호와 외계 행성 숫자의 개수 `len_s`를 입력받습니다.
2.  `numbers` 리스트를 기준으로 외계 행성 숫자들을 정렬하기 위해, **버블 정렬**을 구현하는 함수 `bubble_sort(arr, N)`를 정의합니다.
3.  버블 정렬은 인접한 두 요소를 비교하고, 정렬 순서가 맞지 않으면 교환하는 방식으로 배열을 정렬합니다.
4.  두 숫자의 순서를 비교하기 위해, `numbers.index(arr[j])`와 `numbers.index(arr[j+1])`를 사용하여 각 단어의 순서(인덱스)를 비교합니다.
5.  `for` 반복문을 통해 배열을 순회하며 인접한 두 숫자의 순서가 맞지 않으면 위치를 교환합니다.
6.  `bubble_sort` 함수는 정렬된 배열을 반환합니다.
7.  각 테스트 케이스마다 `bubble_sort` 함수를 호출하여 정렬된 `sorted_s`를 얻고, 테스트 케이스 번호와 정렬된 단어들을 출력 형식에 맞춰 출력합니다.


## 💻 코드
* [1221v2.py](1221v2.py)

---

### 💡 접근 방식 3: 선택 정렬

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 선택 정렬(Selection Sort)

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 배열의 크기 `N`과 숫자 리스트 `arr`를 입력받습니다.
2.  선택 정렬을 구현하는 함수 `selection_sort(arr, N)`를 정의합니다. 이 함수는 리스트를 오름차순으로 정렬합니다.
3.  선택 정렬은 배열을 정렬된 부분과 미정렬된 부분으로 나누어 순회합니다. 바깥쪽 반복문은 `0`부터 `N-2`까지 순회하며 정렬된 부분의 위치를 지정합니다.
4.  안쪽 반복문은 현재 위치(`i`)부터 `N-1`까지 순회하며 미정렬 구간에서 가장 작은 값(`min_idx`)의 위치를 찾습니다.
5.  안쪽 반복문이 끝나면 `arr[i]`와 `arr[min_idx]`의 위치를 교환하여 가장 작은 값을 정렬된 부분의 끝으로 보냅니다.
6.  이 과정이 반복되면서 배열 전체가 정렬됩니다.
7.  `selection_sort` 함수는 정렬된 배열을 반환합니다.
8.  각 테스트 케이스마다 `selection_sort` 함수를 호출하여 정렬된 리스트를 얻고, `*sorted_arr`를 사용하여 공백으로 구분된 형태로 출력합니다.

## 💻 코드
* [1221v3.py](1221v3.py)