# 1953. 탈주범 검거 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PpLlKAQ4DFAUq&categoryId=AV5PpLlKAQ4DFAUq&categoryType=CODE&problemTitle=1953&orderBy=FIRST_REG_DATETIME&selectCodeLang=ALL&select-1=&pageSize=10&pageIndex=1)

## 💡 접근 방식

### 1. 사용 알고리즘
* **너비 우선 탐색 (BFS)**

### 2. 문제 풀이 과정
1.  **초기 설정:** BFS를 위해 `deque`를 사용하고, 탈주범의 시작 위치 `(R, C)`를 큐에 넣습니다. 방문 여부와 소요 시간을 동시에 기록하기 위해 `visited` 2차원 배열을 0으로 초기화하고, 시작점의 소요 시간은 1로 설정합니다.
2.  **터널 구조 매핑:** `types` 딕셔너리를 사용하여 각 터널 종류(`1`부터 `7`까지)에 대해 상하좌우 방향으로 연결이 가능한지 여부를 미리 정의합니다.
3.  **BFS 탐색:** 큐가 빌 때까지 다음 과정을 반복합니다.
    * **현재 위치 확인:** 큐에서 현재 위치 `(now_y, now_x)`를 꺼냅니다.
    * **이동 가능 방향 탐색:** 현재 위치의 터널 종류에 따라 상하좌우 4방향을 순회하며 이동이 가능한지 확인합니다.
    * **이동 조건 검사:** 다음 위치 `(new_y, new_x)`로 이동하기 전에 여러 조건을 검사합니다.
        * 다음 위치가 **미로 범위 밖**인지 확인합니다.
        * 다음 위치에 **터널이 없는지(값이 0)** 확인합니다.
        * 다음 위치를 **이미 방문했는지** 확인합니다.
        * **현재 터널과 다음 터널의 연결성**을 확인합니다. 예를 들어, 현재 터널이 상(위)으로 뚫려 있다면, 다음 터널도 반드시 하(아래)로 뚫려 있어야 합니다.
        * **제한 시간(L)**을 초과하는지 확인합니다. `visited[now_y][now_x] + 1`이 `L`을 초과하면 더 이상 탐색하지 않습니다.
    * **다음 위치 방문:** 위 모든 조건을 만족하면, `visited` 배열에 **소요 시간(이전 시간 + 1)**을 기록하고 다음 위치를 큐에 추가합니다.
4.  **결과 계산:** BFS 탐색이 완료된 후, `visited` 배열을 순회하면서 소요 시간이 1 이상이고 `L` 시간 이하인 모든 칸의 개수를 세어 최종 결과를 도출합니다.

---

## 💻 코드
* [1953.py](1953.py)