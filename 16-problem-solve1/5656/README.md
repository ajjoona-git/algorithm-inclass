# 5656. 벽돌깨기

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo&)

## 💡 접근 방식

### 1. 사용 알고리즘
* **백트래킹 (Backtracking)**
* **너비 우선 탐색 (BFS)**

### 2. 문제 풀이 과정
1.  **백트래킹을 통한 모든 구슬 발사 경우의 탐색:** `shoot` 함수는 재귀적으로 호출되며, N개의 구슬을 W개의 열 중 어디에 쏠지 모든 경우를 탐색합니다. 이는 `N`번의 구슬 발사 횟수를 기준으로 하며, 현재 남은 벽돌의 수가 0이거나 N번의 발사 횟수를 모두 소진하면 탐색을 종료하고 최소 벽돌 수를 갱신합니다.
2.  **구슬 발사 및 연쇄 작용 처리 (BFS):** 각 구슬을 발사할 열(`c`)을 선택한 후, 해당 열의 가장 위에 있는 벽돌을 찾아 `bfs` 함수를 호출합니다. `bfs`는 **너비 우선 탐색(BFS)**을 사용하여 벽돌의 파워만큼 상하좌우로 연쇄적으로 제거되는 벽돌들을 처리합니다. 큐를 이용하여 현재 제거할 벽돌을 담고, 각 벽돌의 파워에 따라 영향을 받는 인접 벽돌들을 큐에 추가하며 탐색을 확장합니다.
3.  **빈 공간 처리 (중력 작용):** `bfs`로 벽돌이 제거된 후, `gravity` 함수를 호출하여 중력에 의해 빈 공간이 채워지도록 합니다. 이는 각 열을 순회하며 벽돌들을 아래로 정렬하는 방식으로 구현됩니다. 큐에 벽돌을 저장한 후, 아래에서부터 다시 쌓아 올리는 방식으로 효율적으로 처리합니다.
4.  **최소 벽돌 수 갱신:** 각 백트래킹 경로가 끝날 때마다 (N번 발사 후 또는 모든 벽돌이 제거된 경우) 현재 남아 있는 벽돌의 수(`blocks`)와 전역 변수 `min_blocks`를 비교하여 최소값을 갱신합니다. 이를 통해 N번의 구슬 발사 후 남을 수 있는 최소 벽돌의 수를 최종적으로 찾게 됩니다.

---

## 💻 코드
* [5656.py](5656.py)