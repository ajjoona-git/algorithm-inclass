# 1248. 공통조상 | D5

## 문제 출처
![SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15PTkqAPYCFAYD)


## 💡 접근 방식

### 1. 사용 알고리즘
* **트리 (Tree)**
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **자료구조 활용 (Parent/Child-list)**

### 2. 문제 풀이 과정
1.  **문제 분할**: 문제를 두 가지 주요 단계로 나눕니다.
    1.  두 노드(`N1`, `N2`)의 **가장 가까운 공통 조상**을 찾는다.
    2.  찾아낸 공통 조상을 루트로 하는 **서브트리의 크기(노드 개수)**를 계산한다.

2.  **효율적인 트리 표현**:
    * 문제 해결을 위해 두 가지 형태의 자료구조를 동시에 사용합니다.
    * **`parents` 배열**: `parents[i]`에 `i`번 노드의 부모 노드를 저장합니다. 이를 통해 특정 노드에서 루트까지 **올라가는(Ascending)** 경로를 빠르게 찾을 수 있습니다.
    * **`children` 리스트**: `children[i]`에 `i`번 노드의 모든 자식 노드를 리스트로 저장합니다. 이를 통해 특정 노드에서 자손으로 **내려가는(Descending)** 경로, 즉 서브트리를 쉽게 탐색할 수 있습니다.

3.  **공통 조상 찾기**:
    * `find_ancestor` 함수는 한 노드에서 시작하여 `parents` 배열을 따라 루트까지 거슬러 올라가며 경로상의 모든 조상을 `set`에 저장합니다.
    * `N1`과 `N2` 각각에 대해 이 함수를 호출하여 두 노드의 모든 조상 집합(`n1_ancs`, `n2_ancs`)을 구합니다.
    * 두 `set`의 **교집합(intersection)**을 구하면 모든 공통 조상을 찾을 수 있습니다. 문제의 조건에 따라 이 교집합에서 가장 큰 값을 가장 가까운 공통 조상으로 선택합니다.

4.  **서브트리 크기 계산**:
    * `dfs_count` 함수는 앞에서 찾은 공통 조상 노드를 시작점(`start`)으로 받습니다.
    * 스택을 이용한 **DFS** 방식으로, `children` 리스트를 따라 해당 노드를 루트로 하는 서브트리에 포함된 모든 노드를 방문합니다.
    * 방문하는 노드의 수를 세어 서브트리의 전체 크기를 계산하고 반환합니다.

5.  **결과 출력**: 공통 조상의 번호와 해당 서브트리의 크기를 형식에 맞게 출력합니다.


---

## 💻 코드
* [1248.py](1248.py)