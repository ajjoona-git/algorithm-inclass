# 1249. 보급로 | D4

## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV15QRX6APsCFAYD)

## 💡 접근 방식

### 1. 사용 알고리즘
* **그래프 (Graph)**
* **최단 경로 (Shortest Path)**
* **다익스트라 알고리즘 (Dijkstra's Algorithm)**
* **우선순위 큐 (Priority Queue) / 힙 (Heap)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: 지도를 하나의 **가중치 그래프(Weighted Graph)**로 간주합니다. 각 칸`(r, c)`은 정점(Vertex)이 되며, 어떤 칸으로 이동할 때 드는 비용(가중치)은 해당 칸에 적힌 복구 시간(`grid[r][c]`)과 같습니다. 문제는 (0, 0)에서 (N-1, N-1)까지의 **최단 경로**를 찾는 것입니다.
2.  **알고리즘 선택**: 간선의 가중치(복구 시간)가 모두 양수이므로, 시작점에서부터 모든 다른 정점까지의 최단 경로를 찾는 데 가장 효율적인 알고리즘 중 하나인 **다익스트라 알고리즘**을 사용합니다.
3.  **다익스트라 알고리즘 구현**:
    * **`dist` 배열**: 시작점 `(0, 0)`으로부터 각 칸 `(r, c)`까지의 최소 복구 비용을 저장하는 2차원 배열입니다. 모든 값을 무한대(INF)로 초기화하고, 시작점 `dist[0][0]`은 `0`으로 설정합니다.
    * **우선순위 큐 (Priority Queue)**: 다음으로 탐색할 정점을 선택할 때, 현재까지 계산된 복구 비용이 가장 적은 정점을 항상 먼저 선택해야 합니다. 이를 효율적으로 구현하기 위해 **최소 힙(min-heap)**을 우선순위 큐로 사용합니다. 큐에는 `(비용, 행, 열)` 튜플을 저장합니다.
4.  **탐색 과정**:
    1.  시작점 `(0, 0, 0)`을 우선순위 큐에 추가합니다.
    2.  큐가 빌 때까지 다음을 반복합니다.
    3.  큐에서 현재까지의 비용이 가장 작은 정점(`curr_d`, `r`, `c`)을 꺼냅니다.
    4.  만약 꺼낸 정점이 도착지 `(N-1, N-1)`이라면, 탐색을 종료하고 해당 비용을 반환합니다. 다익스트라 알고리즘의 특성상, 도착지가 큐에서 나왔을 때의 비용이 곧 최단 경로 비용임이 보장됩니다.
    5.  현재 정점과 인접한 상하좌우 칸들을 탐색하며, 기존에 알려진 비용보다 현재 정점을 거쳐 가는 비용이 더 저렴하다면(`curr_d + grid[nr][nc] < dist[nr][nc]`), `dist` 배열을 갱신하고 해당 칸의 정보 `(갱신된 비용, nr, nc)`를 우선순위 큐에 추가합니다. (Relaxation 과정)
5.  **결과 도출**: `dijkstra(0, 0)` 함수가 반환한 값이 (0, 0)에서 (N-1, N-1)까지의 최소 복구 시간입니다.

---

## 💻 코드
* [1249.py](1249.py)