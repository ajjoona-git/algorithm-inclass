# 4008. 숫자 만들기


## 문제 출처
[SWEA](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWIeRZV6kBUDFAVH)

## 💡 접근 방식

### 1. 사용 알고리즘
* **완전 탐색 (Brute-force Search) / 순열 (Permutations)**
* **깊이 우선 탐색 (DFS, Depth-First Search)**
* **재귀 (Recursion) & 백트래킹 (Backtracking)**

### 2. 문제 풀이 과정
1.  **문제 모델링**: N개의 숫자 사이에 N-1개의 연산자를 배치하는 모든 경우의 수를 탐색하여 최댓값과 최솟값을 찾는 문제입니다. 이는 주어진 연산자 카드를 순서대로 나열하는 모든 **순열(Permutation)**을 고려하는 **완전 탐색** 문제입니다.
2.  **DFS와 백트래킹을 이용한 순열 생성**:
    * 재귀 함수 `get_number(count, number)`를 사용하여 깊이 우선 탐색(DFS) 방식으로 가능한 모든 연산 순서를 생성하고 계산합니다.
    * `count`는 현재까지 사용한 연산자의 개수, `number`는 현재까지의 연산 결과값을 의미합니다.
    * `cards` 리스트는 남은 연산자 카드의 개수를 추적합니다.
3.  **재귀 탐색 과정**:
    * **탐색**: `for` 루프를 통해 4가지 종류의 연산자(`+`, `-`, `*`, `/`)를 확인합니다. 만약 사용할 수 있는 연산자 카드가 남아있다면(`cards[i] > 0`), 해당 연산을 선택합니다.
    * **재귀 호출**: 선택한 연산자 카드의 개수를 하나 줄이고, 현재까지의 결과(`number`)와 다음 숫자(`numbers[count + 1]`)를 이용해 연산을 수행합니다. 이 새로운 결과값과 함께 `count`를 1 증가시켜 다음 연산자를 선택하기 위해 재귀 호출을 합니다.
    * **백트래킹**: 한 연산자에 대한 재귀 호출이 모두 끝나고 돌아오면, **줄였던 연산자 카드의 개수를 다시 하나 늘려 원상 복구**합니다. 이 과정을 통해 다른 계산 경로(다른 순열)에서 해당 연산자를 다시 사용할 수 있도록 합니다.
4.  **종료 조건**:
    * `count`가 `N-1`이 되면 모든 숫자에 대한 연산이 완료된 것입니다.
    * 이때의 최종 결과값을 전역 변수인 `min_number`, `max_number`와 비교하여 최솟값과 최댓값을 갱신합니다.
5.  **실행**: 첫 번째 숫자를 초기값으로 하여 `get_number(0, numbers[0])`를 호출하고, 모든 탐색이 끝난 뒤 `max_number - min_number`를 출력합니다.

---

## 💻 코드
* [4008.py](4008.py)