# 4837. 부분집합의 합 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/solvingProblem/solvingProblem.do)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **구현(Implementation)**
* **비트 연산**을 활용한 부분집합 생성

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 1부터 12까지의 숫자를 원소로 가지는 집합 `A`를 설정합니다.
2.  이 문제는 주어진 `A`의 부분집합 중 **원소의 수가 `N`개이고 합이 `K`가 되는** 부분집합의 개수를 찾아야 하므로, 비트 연산을 사용하여 모든 부분집합을 탐색하는 것이 효율적입니다.
3.  `for i in range(1 << len(A))` 반복문을 통해 공집합을 포함한 모든 부분집합을 확인합니다.
4.  각 `i`에 대해 내부 반복문을 사용하여 해당 부분집합의 합(`sum_of_subset`)과 원소의 개수(`len_of_subset`)를 계산합니다. `if i & (1 << j)` 비트 연산을 통해 `A`의 `j`번째 요소가 부분집합에 포함되는지 확인합니다.
5.  **가지치기(Pruning)**를 통해 불필요한 연산을 줄입니다. 중간에 원소의 개수가 `N`을 초과하거나 합이 `K`를 초과하면, 그 이후의 탐색은 의미가 없으므로 `break`를 통해 반복문을 탈출합니다.
6.  `for` 반복문이 끝난 후, `len_of_subset`이 `N`과 같고 `sum_of_subset`이 `K`와 같으면 조건을 만족하는 부분집합이므로 `count` 변수를 1 증가시킵니다.
7.  모든 부분집합에 대한 탐색이 끝나면 `count`에 저장된 값을 출력 형식에 맞춰 출력합니다.


---

## 💻 코드
* [4837.py](4837.py)

### 💡 접근 방식 2

### 1. 사용 알고리즘
* **구현(Implementation)**
* **비트 연산**을 활용한 부분집합 생성
* **가지치기(Pruning)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 1부터 12까지의 숫자를 원소로 가지는 집합 `A`를 설정합니다.
2.  이 문제는 주어진 `A`의 부분집합 중 **원소의 수가 `N`개이고 합이 `K`가 되는** 부분집합의 개수를 찾아야 하므로, 비트 연산을 사용하여 모든 부분집합을 탐색하는 것이 효율적입니다.
3.  `for i in range(1 << len(A))` 반복문을 통해 공집합을 포함한 모든 부분집합을 확인합니다.
4.  각 `i`에 대해 내부 반복문을 사용하여 해당 부분집합의 합(`sum_of_subset`)과 원소의 개수(`len_of_subset`)를 계산합니다. `if i & (1 << j)` 비트 연산을 통해 `A`의 `j`번째 요소가 부분집합에 포함되는지 확인합니다.
5.  **가지치기(Pruning)**를 통해 불필요한 연산을 줄입니다. 중간에 원소의 개수가 `N`을 초과하거나 합이 `K`를 초과하면, 그 이후의 탐색은 의미가 없으므로 `break`를 통해 반복문을 탈출합니다.
6.  `for` 반복문이 끝난 후, `len_of_subset`이 `N`과 같고 `sum_of_subset`이 `K`와 같으면 조건을 만족하는 부분집합이므로 `count` 변수를 1 증가시킵니다.
7.  모든 부분집합에 대한 탐색이 끝나면 `count`에 저장된 값을 출력 형식에 맞춰 출력합니다.

## 💻 코드
* [4837v2.py](4837v2.py)

---

### 왜 `min_i`, `max_i`를 설정해서 탐색범위를 줄였을 때 연산 시간이 더 길어지는지?

1번 코드의 의도는 이해하지만, **'탐색 범위' 자체의 비효율성** 때문에 2번 코드보다 느린 것입니다. 두 코드 모두 `break` 조건을 사용하지만, 이 조건이 얼마나 효과적으로 작동하느냐의 차이입니다.

---

### 1번 코드의 비효율적인 탐색 범위

1번 코드의 `for i in range(min_i, max_i + 1):`는 N개의 원소를 가진 부분집합(비트마스크)을 찾아내기 위한 의도였습니다. 그러나 이 범위 안에는 N개보다 많거나 적은 비트가 켜진 숫자들이 대량으로 섞여 있습니다.

예를 들어, N=3일 때 `min_i`는 `0b000000000111` (7), `max_i`는 `0b111000000000` (3584)가 됩니다. 이 범위(`7`부터 `3584`) 안에는 `0b1111` (15, 4개의 비트)이나 `0b10000` (16, 1개의 비트)와 같은, N=3 조건에 맞지 않는 숫자들이 포함되어 있습니다.

결론적으로, 1번 코드는 N개의 원소를 가진 부분집합(총 220개)을 찾기 위해 **3,578번의 불필요한 반복**을 수행합니다. 각 반복마다 안쪽 루프를 돌고 `len_of_subset == N`인지 확인해야 하므로 오버헤드가 매우 큽니다.

### 2번 코드의 효율적인 조기 종료

반면 2번 코드는 `for i in range(1 << 12):`를 통해 0부터 4095까지의 모든 경우를 순차적으로 탐색합니다. 이 방식은 언뜻 보면 더 넓은 범위를 도는 것처럼 보이지만, **조기 종료 조건(`break`)의 효과가 극대화**됩니다.

2번 코드는 `i` 값이 순차적으로 증가함에 따라, 안쪽 루프(`for j`)에서 `sum_of_subset`이나 `len_of_subset`이 `K`나 `N`을 초과하는 순간 바로 `break`가 걸리는 경우가 훨씬 많습니다. 예를 들어, `i`가 `0b1111`일 때, 세 번째 비트까지만 검사해도 `len_of_subset`이 3을 초과하므로 바로 다음 `i`로 넘어갈 수 있습니다.

**1번 코드의 탐색 범위는 이러한 순차적인 이점을 누릴 수 없습니다.** 범위 내의 숫자들은 N개의 비트 수에 따라 정렬되어 있지 않기 때문에, `break` 조건이 제대로 발동하기도 전에 불필요한 연산을 하는 경우가 많습니다.

요약하자면, 1번 코드는 **비효율적으로 넓은 범위**를 탐색하며, `break` 조건의 이점을 제대로 활용하지 못해 시간이 오래 걸립니다. 2번 코드는 전체 범위를 탐색하지만, **순차적인 탐색과 효과적인 `break` 조건** 덕분에 실제 연산량은 훨씬 적어 빠르게 실행되는 것입니다.
