# 4837. 부분집합의 합 | D3

## 문제 출처
[SWEA](https://swexpertacademy.com/main/solvingProblem/solvingProblem.do)

## 💡 접근 방식 1

### 1. 사용 알고리즘
* **구현(Implementation)**
* **비트 연산**을 활용한 부분집합 생성

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 1부터 12까지의 숫자를 원소로 가지는 집합 `A`를 설정합니다.
2.  이 문제는 주어진 `A`의 부분집합 중 **원소의 수가 `N`개이고 합이 `K`가 되는** 부분집합의 개수를 찾아야 하므로, 비트 연산을 사용하여 모든 부분집합을 탐색하는 것이 효율적입니다.
3.  `for i in range(1 << len(A))` 반복문을 통해 공집합을 포함한 모든 부분집합을 확인합니다.
4.  각 `i`에 대해 내부 반복문을 사용하여 해당 부분집합의 합(`sum_of_subset`)과 원소의 개수(`len_of_subset`)를 계산합니다. `if i & (1 << j)` 비트 연산을 통해 `A`의 `j`번째 요소가 부분집합에 포함되는지 확인합니다.
5.  **가지치기(Pruning)**를 통해 불필요한 연산을 줄입니다. 중간에 원소의 개수가 `N`을 초과하거나 합이 `K`를 초과하면, 그 이후의 탐색은 의미가 없으므로 `break`를 통해 반복문을 탈출합니다.
6.  `for` 반복문이 끝난 후, `len_of_subset`이 `N`과 같고 `sum_of_subset`이 `K`와 같으면 조건을 만족하는 부분집합이므로 `count` 변수를 1 증가시킵니다.
7.  모든 부분집합에 대한 탐색이 끝나면 `count`에 저장된 값을 출력 형식에 맞춰 출력합니다.


---

## 💻 코드
* [4837.py](4837.py)

### 💡 접근 방식 2

### 1. 사용 알고리즘
* **구현(Implementation)**
* **비트 연산**을 활용한 부분집합 생성
* **가지치기(Pruning)**

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 1부터 12까지의 숫자를 원소로 가지는 집합 `A`를 설정합니다.
2.  이 문제는 주어진 `A`의 부분집합 중 **원소의 수가 `N`개이고 합이 `K`가 되는** 부분집합의 개수를 찾아야 하므로, 비트 연산을 사용하여 모든 부분집합을 탐색하는 것이 효율적입니다.
3.  `for i in range(1 << len(A))` 반복문을 통해 공집합을 포함한 모든 부분집합을 확인합니다.
4.  각 `i`에 대해 내부 반복문을 사용하여 해당 부분집합의 합(`sum_of_subset`)과 원소의 개수(`len_of_subset`)를 계산합니다. `if i & (1 << j)` 비트 연산을 통해 `A`의 `j`번째 요소가 부분집합에 포함되는지 확인합니다.
5.  **가지치기(Pruning)**를 통해 불필요한 연산을 줄입니다. 중간에 원소의 개수가 `N`을 초과하거나 합이 `K`를 초과하면, 그 이후의 탐색은 의미가 없으므로 `break`를 통해 반복문을 탈출합니다.
6.  `for` 반복문이 끝난 후, `len_of_subset`이 `N`과 같고 `sum_of_subset`이 `K`와 같으면 조건을 만족하는 부분집합이므로 `count` 변수를 1 증가시킵니다.
7.  모든 부분집합에 대한 탐색이 끝나면 `count`에 저장된 값을 출력 형식에 맞춰 출력합니다.

## 💻 코드
* [4837v2.py](4837v2.py)

---

### 💡 풀이 1 vs 풀이 2 연산 시간 비교

* **풀이 1의 작동 방식 (1573ms)**
    * `for i in range(1 << len(A))`를 통해 모든 부분집합(2^12 = 4096개)을 순차적으로 탐색합니다. 
    * 각 부분집합의 원소 개수(`len_of_subset`)와 합(`sum_of_subset`)을 계산하는 도중 `N`이나 `K`를 초과하면 **즉시 `break`하는 '가지치기'가 적용**됩니다. 
    * 이 방식은 원소 개수가 적은 부분집합부터 순차적으로 탐색하므로, 가지치기가 효과적으로 작동하여 전체 연산 시간을 단축시킵니다.

* **풀이 2의 작동 방식 (1700ms)**
    * `min_i = 2 ** N - 1`부터 `max_i = min_i << (12 - N)`까지의 범위로 반복문을 설정합니다.
    * 하지만 이 범위에는 **원소의 개수가 `N`개가 아닌 부분집합을 나타내는 숫자(즉, 1의 개수가 `N`개가 아닌 이진수)**가 훨씬 더 많이 포함됩니다. 
    * 결과적으로 풀이 2는 원소 개수가 `N`개가 아닌 수많은 부분집합을 여전히 불필요하게 탐색해야 합니다.
    * 여기에 `min_i`와 `max_i`를 계산하는 추가적인 연산 오버헤드까지 발생하므로, 풀이 1과 동일한 가지치기 로직이 있음에도 불구하고 전체 실행 시간이 더 길어지는 것입니다.

**결론적으로, 풀이 1의 단순하고 넓은 범위의 반복문과 효과적인 가지치기 로직이 풀이 2의 비효율적인 탐색 범위 설정보다 더 나은 성능을 보여주었습니다.**
