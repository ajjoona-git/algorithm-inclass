# 1966. 숫자를 정렬하자 | D2

## 문제 출처
[SWEA](https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZh9Pr4Kw1nHBINp&contestProbId=AV5PrmyKAWEDFAUq&probBoxId=AZh9Pr4Kw1rHBINp&type=PROBLEM&problemBoxTitle=List&problemBoxCnt=54)

## 💡 접근 방식 1: 버블 정렬

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 버블 정렬(Bubble Sort)

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 배열의 크기 `N`과 숫자 리스트 `arr`를 입력받습니다.
2.  버블 정렬을 구현하는 함수 `bubble_sort(arr, N)`를 정의합니다.
3.  버블 정렬은 인접한 두 요소를 비교하고, 정렬 순서가 맞지 않으면 교환하는 방식으로 배열을 정렬합니다. 바깥쪽 반복문은 `N-1`부터 `1`까지 감소하면서 정렬할 범위의 끝을 지정합니다.
4.  안쪽 반복문은 `0`부터 `i`까지 순회하며 인접한 두 요소 `arr[j]`와 `arr[j+1]`을 비교합니다.
5.  `arr[j]`가 `arr[j+1]`보다 크다면, 두 요소의 위치를 교환하여 더 큰 값을 뒤로 이동시킵니다.
6.  안쪽 반복문이 한 번 완료될 때마다 가장 큰 값이 배열의 가장 오른쪽으로 이동하게 됩니다.
7.  `bubble_sort` 함수는 정렬된 배열을 반환합니다.
8.  각 테스트 케이스마다 `bubble_sort` 함수를 호출하여 정렬된 리스트를 얻고, `*sorted_arr`를 사용하여 공백으로 구분된 형태로 출력합니다.

---

## 💻 코드
* [1966.py](1966.py)



### 💡 접근 방식 2: 선택 정렬

### 1. 사용 알고리즘
* **구현(Implementation)**
* **정렬 알고리즘(Sorting Algorithm)** - 선택 정렬(Selection Sort)

### 2. 문제 풀이 과정
1.  먼저 테스트 케이스의 개수 `T`를 입력받고, 각 테스트 케이스마다 배열의 크기 `N`과 숫자 리스트 `arr`를 입력받습니다.
2.  선택 정렬을 구현하는 함수 `selection_sort(arr, N)`를 정의합니다. 이 함수는 리스트를 오름차순으로 정렬합니다.
3.  선택 정렬은 배열을 정렬된 부분과 미정렬된 부분으로 나누어 순회합니다. 바깥쪽 반복문은 `0`부터 `N-2`까지 순회하며 정렬된 부분의 위치를 지정합니다.
4.  안쪽 반복문은 현재 위치(`i`)부터 `N-1`까지 순회하며 미정렬 구간에서 가장 작은 값(`min_idx`)의 위치를 찾습니다.
5.  안쪽 반복문이 끝나면 `arr[i]`와 `arr[min_idx]`의 위치를 교환하여 가장 작은 값을 정렬된 부분의 끝으로 보냅니다.
6.  이 과정이 반복되면서 배열 전체가 정렬됩니다.
7.  `selection_sort` 함수는 정렬된 배열을 반환합니다.
8.  각 테스트 케이스마다 `selection_sort` 함수를 호출하여 정렬된 리스트를 얻고, `*sorted_arr`를 사용하여 공백으로 구분된 형태로 출력합니다.

---

### 💻 코드
* [1966v2.py](1966v2.py)